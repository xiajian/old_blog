---
layout: post
title: 理解Unix进程的笔记
---

Unix编程模型，能力越大，责任越大。web服务器-Spyglass，各种学到的概念。用户空间(userland)和内核。

通信通过系统调用(system call)完成。手册页: 1-命令，2-系统调用，3-C库函数，4-特殊文件。

Process.pid

Process.ppid # 检测守护进程

IO对象，文件描述符的特征，重定向的前提条件

文件描述符是套接字、管道等网络编程的核心所在，也是文件系统的核心所在。

系统调用: open, close, read, write, pipe, fsync, stat等。

Process.getrlimit(:NOFILE) #参数可变，:NPROC-用户允许的最大并发进程数，:FSIZE-最大文件数，:STACK-进程最大的段

个人机器: [1024, 4096] vs [2560, 9223372036854775807]。软限制和硬限制，系统级别的限制-sysctl调用

Process的getrlimit和setrlimit分别对应于getrlimit和setrlimit系统调用。环境变量是包含进程数据的键-值对(key-value pairs)。

VAR=value是bash设置环境变量的方法，可以在Ruby中通过ENV常量来实现，键值对是理解的关键。

环境变量作为将输入传递命令行程序的通用方法，比命令行解析开销小。C库函数: setenv和getenv

参数: ARGV-参数向量。读取ARGV，解析命令行选项的库-optparse。

Unix程序-固有的方式了解彼此的状态。日志-文件系统，套接字-网络，运行在进程自身上的机制：进程名称，退出码。

$PROGRAM_NAME获取并设置当前进程的名称，Resque如何管理进程。

退出码为0表示进程顺利结束，exit和exit!: exit xxx会调用at_exit，abort提供了一种从错误进程中退出的通用方法，raise抛出异常，沿着调用栈向上传递，终结进程，调用at_exit。

衍生是Unix编程中的强大概念，fork多进程-不再是终端控制一切，孤儿进程：守护进程，长期运行的进程；脱离终端会话的进程进行通信。

fork进程：Copy on Write。MRI或者Rubinius不支持CoW。Ruby企业版(REE)。Ruby 2.0提供CoW友好的垃圾收集器。



